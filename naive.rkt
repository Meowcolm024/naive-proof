#lang racket

;; ('proof 'a)
;; ('infer 'a 'b)
;; ('fail)
;; ('and 'a 'b)
;; ('or 'a 'b)
;; ('not 'a)

(define (simplify pf)
  (define (handle-and np p)
    (let ((tag (car p)) (body (cdr p)))
      (cond ((eq? tag 'or ) 
            (let ((l (car body)) (r (cadr body)))
              (cond ((eq? np l) (simplify np))
                    ((eq? np r) (simplify np))
                    (else (append (list 'proof np) (simplify p))))))
            (else (list 'and np (simplify p))))))

  (define (handle-or np p)
    (let ((tag (car p)) (body (cdr p)))
      (cond ((eq? tag 'and ) 
            (let ((l (car body)) (r (cadr body)))
              (cond ((eq? np l) (simplify np))
                    ((eq? np r) (simplify np))
                    (else (append (list 'proof np) (simplify p))))))
            (else (list 'or np (simplify p))))))
  
  (if (not (pair? pf))
    pf
    (let ((tag (car pf)) (body (cdr pf)))
      (cond ((eq? tag 'not )
             (if (pair? (car body))
                (let ((tag-b (car (car body))) (body-b (cdr (car body))))
                  (cond ((eq? 'not tag-b) 
                        (simplify (car body-b)))
                       ;; DeMorgan's Law
                       ((eq? 'and tag-b)
                        (list 'or (simplify (list 'not (car body-b))) (simplify (list 'not (cadr body-b)))))
                       ((eq? 'or tag-b)
                        (list 'and (simplify (list 'not (car body-b))) (simplify (list 'not (cadr body-b)))))
                       (else (list 'not body))))
                 pf))
            ((eq? tag 'and )
              (let ((left (car body)) (right (cadr body)))
                (cond ((eq? left right) left)
                      ((and (pair? left) (not (pair? right))) (handle-and right left))
                      ((and (pair? right) (not (pair? left))) (handle-and left right))
                      (else (list 'and (simplify (car body)) (simplify (cadr body)))))))
            ((eq? tag 'or )
              (let ((left (car body)) (right (cadr body)))
                (cond ((eq? left right) left)
                      ((and (pair? left) (not (pair? right))) (handle-or right left))
                      ((and (pair? right) (not (pair? left))) (handle-or left right))
                      (else (list 'or (simplify (car body)) (simplify (cadr body)))))))
            (else pf)))))


(define (expend pf)
  (define (expend-pf pf)
    (if (not (pair? pf))
        (list (list 'proof pf))
        (let ((tag (car pf)) (body (cdr pf)))
          (cond ((eq? tag 'not ) (list (list 'proof pf)))
                ((eq? tag 'and ) (append (expend-pf (car body)) (expend-pf (cadr body))))
                (else (list (list 'proof pf)))))))
  
  (let ((tag (car pf)) (body (cdr pf)))
    (cond ((eq? tag 'proof ) (expend-pf (car body)))
          ((eq? tag 'infer ) (list pf))
          (else (expend-pf pf)))))


(define (simp-all pf)
  (let ((tag (car pf)) (body (cdr pf)))
    (cond ((eq? tag 'proof )
           (list 'proof (simplify (car body))))
          ((eq? tag 'infer )
           (list 'infer (simplify (car body)) (simplify (cadr body))))
          (else pf))))


(define (do-proof statements)
  (let ((proofs (foldr append '() (map (lambda (x) (expend (simp-all x))) statements))))
    (begin
      (displayln proofs)
      (displayln (apply-infer proofs)))))


(define (sat proofs p)
  (if (null? proofs)
      #f
      (or (eq? (cadr (car proofs)) p)
          (sat (cdr proofs) p))))


(define (apply-infer proofs)
  (define (dispatch pfs ifs)
    (define (handle inf)
      (define (comp x)
        (if (pair? x)
          (let ((tag (car x)) (body (cdr x)))
              (cond ((eq? tag 'and )
                      (and (comp (car body)) (comp (cadr body))))
                    ((eq? tag 'or )
                      (or (comp (car body)) (comp (cadr body))))
                    ((eq? tag 'not )
                     (not (comp (car body))))
                    (else #f)))
          (sat pfs x)))
      (let ((left (car inf)) (right (cadr inf)))  
          (if (comp left) right 'fail ))
    )

    (define (handle-infer inf)
      (let ((ra (handle inf)))
        (if (eq? ra 'fail )
          (let ((rb (handle (list (simplify (list 'not (cdr inf))) (simplify (list 'not (car inf)))))))
            (if (eq? rb 'fail )
            'fail
            rb))
          ra)))
    
    (if (eq? (length ifs) 1)
      (let ((tag (car (car ifs))) (body (cdr (car ifs))))
        (cond ((eq? tag 'proof ) body)
              ((eq? tag 'infer ) (handle-infer body))
              (else 'fail )))
      (let ((current (car ifs)) (rest (cdr ifs)))
        (let ((tag (car current)) (body (cdr current)))
          (cond ((eq? tag 'proof ) (dispatch (cons current pfs) rest))
                ((eq? tag 'infer ) 
                  (let ((result (handle-infer body))) 
                    (if (eq? result 'fail ) 
                      'fail 
                      (dispatch (cons (list 'proof result) pfs) rest))))
                (else 'fail ))))))

  (dispatch null proofs)
)

(do-proof '(
  (proof (and (not p) q))
  (infer r p)
  (infer (not r) t)
))